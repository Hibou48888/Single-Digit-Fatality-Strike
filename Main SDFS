//due to the jerkiness of the motion in shift(), a flash should be implemented that covers up the abruptness of the shift
//suggest placing a rect over the entire screen at the end that has fill(x), with x decreasing in opacity to give it a flash effect.

color background;
player p;
int score;
int shift;    //what does this do?
float difficulty;  //controls the speed of the enemies
int missLag;      //basically the time remaining until the player can attack again after missing
ArrayList<Enemy> eListLeft;
ArrayList<Enemy> eListRight;

void setup()
{
  background = color(60, 60, 60);
  background(background);
  size(1200, 600);
  fill(255);
  noStroke();
  smooth();
  rectMode(CENTER);
  imageMode(CENTER);
  score = 0;
  shift = 0;
  difficulty = 1.5;
  missLag = 0;
  p = new player();
  eListLeft = new ArrayList<Enemy>();
  eListRight = new ArrayList<Enemy>();

}

void draw()
{
  background(background);
  
  fill(255);
  text(p.health, width - 20, 10);
  p.render(); //v important
  
  //this next segment spawns the enemies
  if ((int)random(150) == 0)
  {
    if((int)random(2) == 0)
      eListLeft.add(new Enemy("LEFT", difficulty));  //adds an enemy that spawn on the RIGHT facing LEFT
    else
      eListRight.add(new Enemy("RIGHT", difficulty));  //adds an enemy that spawn on the LEFT facing RIGHT
  }

  //goes through the list of enemies and renders them and then moves them
  //also flips them if they are facing the wrong direction
  for (Enemy e : eListLeft)
  {
    if (e != null)
    {
      if(e.wayFacing.equals("RIGHT") && e.x > p.playerX)
        e.wayFacing = "LEFT";
      if(e.wayFacing.equals("LEFT") && e.x < p.playerX)
        e.wayFacing = "RIGHT";
      e.speed = difficulty;
      e.render();
      e.tick();
    }
  }
  for (Enemy e : eListRight) //does the same as above
  {
    if (e != null)
    {
      if(e.wayFacing.equals("RIGHT") && e.x > p.playerX)
        e.wayFacing = "LEFT";
      if(e.wayFacing.equals("LEFT") && e.x < p.playerX)
        e.wayFacing = "RIGHT";
      e.speed = difficulty;
      e.render();
      e.tick();
    }
  }
    
  //next two segments cause enemies to attack when within range
  if(eListLeft.size() != 0 && eListLeft.get(0) != null)//if there's an enemy in the list
  {
    if (eListLeft.get(0).x <= p.playerX + eListLeft.get(0).wide)  //if the enemy reaches a certain range of the player (basically next to the player)
    {
      shift(eListLeft.get(0).x/5); //moves all of the enemie to right
      difficulty = 0;
      missLag = 20;
      p.health--;
      score--;
    }
  }
  
  if(eListRight.size() != 0 && eListRight.get(0) != null)
  {
    if (eListRight.get(0).x >= p.playerX - eListRight.get(0).wide)  //if the enemy reaches a certain range of the player
    {
      shift(-eListRight.get(0).x/5); //moves all of the enemies to the left
      difficulty = 0;
      missLag = 20;
      p.health--;
      score--;
    }
  }
  
  //brings speed of enemies back up to its original amount (hardcoded at 1.5 for now)
  if(difficulty < 1.5)
  {
    if(difficulty < .05)  //after it gets past .05, increments at a higher value
      difficulty += .005;
    else
      difficulty += .01;
  }
  
  //acts as a timer counting down to when the player can attack again
  if(missLag > 0)
    missLag--;
    
  println(missLag);
}


void keyPressed()
{
  if (keyCode == RIGHT && missLag == 0)  //if right arrow is pressed and the player didn't just miss
  {
    if (eListLeft.size() > 0 && eListLeft.get(0) != null && eListLeft.get(0).x > p.playerX && eListLeft.get(0).x <= p.playerX + p.range)  //if there's an enemy and it's within range
    { 
      shift(p.playerX - eListLeft.get(0).x); //shifts everything around the player
      eListLeft.remove(0); //deletes the thing
      score++; //pretty self explanitory
    }
    else  //if there are no enemies in range and the player will miss
    {
      shift(-p.range);  //"moves" the player
      missLag = 50;  //stuns the player for a bit
    }
  }
  
  if (keyCode == LEFT && missLag == 0)  //if left arrow is pressed and the player didn't just miss
  {
    if (eListRight.size() > 0 && eListRight.get(0) != null && eListRight.get(0).x < p.playerX && eListRight.get(0).x > p.playerX - p.range)  //if there's an enemy and it's within range
    { 
      shift(p.playerX - eListRight.get(0).x); //shifts everything around the player
      eListRight.remove(0); //deletes the thing
      score++; //pretty self explanitory
    }
    else  //if there are no enemies in range and the player will miss
    {
      shift(p.range);  //"moves" the player
      missLag = 50;  //stuns the player for a bit
    }
  }
}



void shift(float dist)
{
  for (Enemy e : eListLeft)
    e.x += dist; //dist can be negative, so it goes both ways
  for (Enemy e : eListRight)
    e.x += dist;
}

//this method will shake by translating randomly each time it is called
//this method will take a boolean, which is initially false until some event in the main method makes it true
//when the taken boolean is true, translate() will be called in a random direction and some int will be set to a certain amount
//the main method will decrease the int until it is 0, at which point the boolean passed as an argument for this method will be set to false
void screenShake(boolean isShake)
{
  //help
}

//general idea is to decrease the speed at which the enemies move.
//the main method will increase the speed back up to default 
void timeSlow(int seconds)
{
  //placeholder
}

void mouseClicked()
{
  eListLeft.add(new Enemy("LEFT"));
}
